/**
 * Backtest script for the binary options prediction bot (v3).
 *
 * This script loads a CSV file containing 1â€‘minute price data for XAUUSD,
 * generates synthetic volumes based on the time of day, and then feeds
 * the candles into the existing preFilter and GPT signal logic.  When
 * a trade signal is produced (signal is "UP" or "DOWN" and confidence
 * meets a threshold), the script opens a virtual trade lasting one
 * minute.  It then checks the next candle to determine whether the
 * prediction was correct.  At the end of the run, a summary of the
 * total trades, correct trades and overall accuracy is printed.
 *
 * Usage:
 *   node backtest.js [--file path] [--minutes N]
 *
 * Arguments:
 *   --file     Path to the CSV file (default: DAT_MT_XAUUSD_M1_202507.csv)
 *   --minutes  How many minutes of data to simulate (default: 2880 for 2 days)
 *
 * Before running this script, ensure you have set the following
 * environment variables (e.g. in a .env file or via the command line):
 *   OPENAI_API_KEY   The API key for the OpenAI API
 *   OPENAI_MODEL     The model identifier (e.g. gpt-4o)
 *   TV_SYMBOL        The symbol you want to analyse (e.g. XAUUSD)
 *
 * Note:
 *   This script intentionally invokes GPT only when the preFilter
 *   determines there is sufficient confluence to justify a trade.  If the
 *   dataset does not meet those criteria, few or no GPT calls will be
 *   made, and the backtest may produce no trades.
 */

const fs = require('fs');
const path = require('path');
const dotenv = require('dotenv');

// Load environment variables from .env if present
dotenv.config({ path: path.resolve(__dirname, '.env') });

const preFilter = require('./core/preFilter');
const { calculateEMA } = require('./core/indicators');
// Pull in ADX from technicalindicators for volatility/trend strength filtering
const { ADX } = require('./node_modules/technicalindicators');
// Note: In the original live bot, signals are generated by GPT via
// `gptSignalChecker_v3.js`.  Since external API calls are not
// permitted in this offline environment, we derive a simple
// deterministic signal from the preFilter output.  The logic below
// attempts to capture the spirit of the GPT prompts by favouring
// trades in the direction of the fast EMA trend and respecting
// volume biases.  If additional confirmations are present, the
// confidence is increased.

/**
 * Derive a pseudoâ€‘GPT signal from the preFilter result.  If the
 * filter indicates a trend is up (EMA7 > EMA20), this returns
 * an "UP" signal, and if the trend is down, returns "DOWN".
 * Confidence is computed based on the number of confirmations.
 * The volume bias can veto a trade if it conflicts with the trend.
 *
 * @param {object} filter The result returned from preFilter()
 * @returns {{signal:string, confidence:number, skipped:boolean}}
 */
function deriveSignal(filter, history) {
  // No trade if the base filter fails
  if (!filter.shouldTrade || history.length < 22) {
    return { signal: 'NONE', confidence: 0, skipped: true };
  }
  const closes = history.map(c => c.close);
  const highs = history.map(c => c.high);
  const lows = history.map(c => c.low);
  // Compute EMA14 and EMA21 for crossover strategy
  const ema14Arr = calculateEMA(closes, 14);
  const ema21Arr = calculateEMA(closes, 21);
  const ema14 = ema14Arr.at(-1);
  const ema21 = ema21Arr.at(-1);
  const ema14Prev = ema14Arr.at(-2);
  const ema21Prev = ema21Arr.at(-2);
  const crossUp = ema14Prev < ema21Prev && ema14 > ema21;
  const crossDown = ema14Prev > ema21Prev && ema14 < ema21;
  // Compute Bollinger Bands (20 EMA Â± 2 std dev)
  const ema20Arr = calculateEMA(closes, 20);
  const ema20 = ema20Arr.at(-1);
  const last20 = closes.slice(-20);
  const mean = last20.reduce((sum, v) => sum + v, 0) / last20.length;
  const variance = last20.reduce((sum, v) => sum + (v - mean) ** 2, 0) / last20.length;
  const sd = Math.sqrt(variance);
  const upperBand = ema20 + 2 * sd;
  const lowerBand = ema20 - 2 * sd;
  const price = closes.at(-1);
  const prevPrice = closes.at(-2);
  const bounceUp = prevPrice < lowerBand && price >= lowerBand;
  const bounceDown = prevPrice > upperBand && price <= upperBand;
  // Compute ADX to assess trend strength over the last 14 periods
  let adxOk = true;
  try {
    const adxArr = ADX.calculate({ high: highs, low: lows, close: closes, period: 14 });
    const currentAdx = adxArr.at(-1);
    // Consider valid only if ADX exists and exceeds 15 (trend strength filter)
    if (currentAdx !== undefined && currentAdx < 15) adxOk = false;
  } catch (e) {
    adxOk = true; // If calculation fails, don't filter by ADX
  }
  // Determine time-of-day filter (only trade during 08:00-22:00)
  // Optional time-of-day filtering could be added here if desired.
  // Determine base trend from filter
  let trendDirection = null;
  for (const c of filter.confirmations) {
    if (c.startsWith('Fast Trend: UP')) trendDirection = 'UP';
    if (c.startsWith('Fast Trend: DOWN')) trendDirection = 'DOWN';
  }
  // Abort if ADX indicates a weak or non-existent trend
  if (!adxOk) {
    return { signal: 'NONE', confidence: 0, skipped: true };
  }
  // Count confluences
  let confluences = 0;
  let direction = null;
  if (crossUp) { confluences++; direction = 'UP'; }
  if (crossDown) { confluences++; direction = 'DOWN'; }
  if (bounceUp) { confluences++; direction = 'UP'; }
  if (bounceDown) { confluences++; direction = 'DOWN'; }
  if (trendDirection) { confluences++; direction = trendDirection; }
  // Use momentum shift from filter as additional confluence
  if (filter.confirmations.some(c => c.includes('Momentum Shift'))) confluences++;
  // Use RSI bounce as additional confluence
  if (filter.confirmations.some(c => c.includes('RSI bounce'))) confluences++;
  // Use volume spike on reversal candle as additional confluence
  if (filter.confirmations.some(c => c.includes('Volume Spike'))) confluences++;
  // Resolve direction; if conflicting signals (both up and down) skip trade
  if (!direction) {
    return { signal: 'NONE', confidence: 0, skipped: true };
  }
  // Volume bias veto
  const vb = filter.context.volumeBias;
  if ((vb === 'SELL_BIAS' && direction === 'UP') || (vb === 'BUY_BIAS' && direction === 'DOWN')) {
    return { signal: 'NONE', confidence: 0, skipped: true };
  }
  // Require at least four confluences for a valid trade (stricter filtering)
  if (confluences < 4) {
    return { signal: 'NONE', confidence: 0, skipped: true };
  }
  // Compute confidence: base 70 + 5 per confluence above 2
  const base = 70;
  const extraConf = Math.max(0, confluences - 2) * 5;
  const confidence = Math.min(100, base + extraConf);
  return { signal: direction, confidence, skipped: false };
}

/**
 * Generate a synthetic volume based on the hour of the day.  The XAUUSD
 * market tends to exhibit lower activity overnight, moderate activity
 * during the European session and higher activity during the US session.
 *
 * @param {string} timeString HH:MM formatted time (24h)
 * @returns {number} random volume between 100 and 1500
 */
function getSyntheticVolume(timeString) {
  const hour = parseInt(timeString.split(':')[0], 10);
  let min = 100;
  let max = 1500;
  // Asian session (00:00â€“07:59) â€“ lower volumes
  if (hour < 8) {
    max = 400;
  } else if (hour < 16) {
    // European session (08:00â€“15:59)
    min = 400;
    max = 800;
  } else {
    // US session (16:00â€“23:59)
    min = 800;
    max = 1500;
  }
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

/**
 * Parse the CSV file into an array of candle objects.  Each line of
 * the dataset has the form:
 *   YYYY.MM.DD  HH:MM  open  high  low  close  volume
 * Volume in the file is ignored in favour of synthetic volumes.
 *
 * @param {string} csvPath
 * @param {number} maxRows  optional maximum number of rows to read
 * @returns {Array<{open:number, high:number, low:number, close:number, volume:number}>}
 */
function loadCandles(csvPath, maxRows) {
  const content = fs.readFileSync(csvPath, 'utf8');
  const lines = content.split(/\r?\n/);
  const candles = [];
  for (const line of lines) {
    if (!line.trim()) continue;
    // The dataset is comma separated (date,time,open,high,low,close,volume)
    const parts = line.trim().split(',');
    if (parts.length < 7) continue;
    const timeStr = parts[1];
    // Extract hour for session filtering
    const [hh, mm] = parts[1].split(':');
    const candle = {
      open: parseFloat(parts[2]),
      high: parseFloat(parts[3]),
      low: parseFloat(parts[4]),
      close: parseFloat(parts[5]),
      volume: getSyntheticVolume(timeStr),
      hour: parseInt(hh, 10)
    };
    candles.push(candle);
    if (maxRows && candles.length >= maxRows) break;
  }
  return candles;
}

/**
 * Main backtest routine.  Iterates through the candle data, calling the
 * preFilter and GPT signal generator when there is enough history and
 * opening virtual trades when criteria are met.  Tracks the outcome
 * one candle later.
 */
async function backtest() {
  // Parse arguments
  const args = process.argv.slice(2);
  let csvFile = 'DAT_MT_XAUUSD_M1_202507.csv';
  let maxMinutes = 2880; // default to 2 days of 1â€‘minute candles
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (arg === '--file' && args[i + 1]) {
      csvFile = args[i + 1];
      i++;
    } else if (arg === '--minutes' && args[i + 1]) {
      maxMinutes = parseInt(args[i + 1], 10);
      i++;
    }
  }
  const csvPath = path.resolve(__dirname, csvFile);
  if (!fs.existsSync(csvPath)) {
    console.error(`âŒ CSV file not found: ${csvPath}`);
    process.exit(1);
  }
  // Load candles up to maxMinutes
  const candlesData = loadCandles(csvPath, maxMinutes);
  if (candlesData.length < 221) {
    console.error('âŒ Not enough candles loaded for backtesting.');
    return;
  }
  // Settings
  const symbol = process.env.TV_SYMBOL || process.env.SYMBOL || 'XAUUSD';
  const confidenceThreshold = 75;
  const history = [];
  let openTrades = [];
  let totalTrades = 0;
  let correctTrades = 0;

  for (let i = 0; i < candlesData.length; i++) {
    const candle = candlesData[i];
    history.push(candle);
    // Maintain sliding history; no need to trim but can limit growth
    // Evaluate any trades that have reached their expiry (1 minute)
    if (openTrades.length) {
      // Create a copy as we may modify openTrades while iterating
      const remaining = [];
      for (const trade of openTrades) {
        if (trade.expiryIndex === i) {
          const resultUp = candlesData[i].close > trade.entryPrice;
          const resultDown = candlesData[i].close < trade.entryPrice;
          const isCorrect = (trade.direction === 'UP' && resultUp) || (trade.direction === 'DOWN' && resultDown);
          if (isCorrect) correctTrades++;
          totalTrades++;
        } else {
          remaining.push(trade);
        }
      }
      openTrades = remaining;
    }
    // Only start generating signals once we have enough history (>=220 candles)
    if (history.length < 220) continue;
    // Evaluate the current history with the preFilter
    const filterResult = preFilter(history);
    // Derive a pseudoâ€‘GPT signal from the filter and history
    const signal = deriveSignal(filterResult, history);
    if (
      !signal.skipped &&
      ['UP', 'DOWN'].includes(signal.signal) &&
      typeof signal.confidence === 'number' &&
      signal.confidence >= confidenceThreshold
    ) {
      // Open a virtual trade lasting 1 minute (i + 1)
      openTrades.push({
        entryIndex: i,
        expiryIndex: i + 1,
        direction: signal.signal,
        entryPrice: candle.close
      });
    }
  }
  // Output results
  console.log('ðŸ“Š Backtest completed');
  console.log(`Total trades opened: ${totalTrades}`);
  console.log(`Correct trades:      ${correctTrades}`);
  const accuracy = totalTrades > 0 ? (correctTrades / totalTrades) * 100 : 0;
  console.log(`Accuracy:           ${accuracy.toFixed(2)}%`);
}

if (require.main === module) {
  backtest().catch(err => {
    console.error(err);
  });
}